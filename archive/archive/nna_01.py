#coding:utf-8
import sys, select
import tty, fcntl, os
import time, termios, atexit
import smbus
#-------------------------------------------------------------------------------
# Делается tries попыток записи байта byte по шине I2C в ведомое устройство 
# с адресом addr.
def try_write_byte(addr, byte, tries = 10):
  assert(tries > 0)
  error = None
  while tries: # Если будет сбой при записи - сделаем несколько попыток
    try:
      bus.write_byte(addr, byte)
    except IOError as e:
      error = e
      tries -= 1
      print "tries = " + str(tries) + "; " + str(error)
    else:
      break

  if not tries: # Сбой устойчивый - бросаем исключение и завязываем с этим делом
    raise error
#-------------------------------------------------------------------------------
def kbhit(): # Проверка нажата ли клавиша
  return poller.poll(timeout)
#-------------------------------------------------------------------------------
def restore_term(): # Возврат к старому терминалу (для регистрации в atexit())
  termios.tcsetattr(fd, termios.TCSAFLUSH, old_settings)
#-------------------------------------------------------------------------------
def all_off(): # "Подчистки" по завершению работы
#  try_write_byte(addrPDM, 0) # Выключаем ТЭН
  if not log.closed:
    log.close()
  print "done..."
#-------------------------------------------------------------------------------
def read_raw(fn): # Чтение "сырых" данных с датчика температуры (файл fn)
  f = open(fn, 'r')
  lines = f.readlines()
  f.close()
  return lines
#-------------------------------------------------------------------------------
def read_temp(fn): # Получение значения температуры 
  lines = read_raw(fn)
  while lines[0].strip()[-3:] != 'YES': # Пока преобразование не закончено
    lines = read_raw(fn)
  pos = lines[1].find('t=') # Значение температуры после 't='
  if pos != -1:
    return float(lines[1][pos + 2:])/1000
  return -1
#-------------------------------------------------------------------------------
#addrPDM = 0x04 # i2c-адрес регулятора мощности

fn0 = "/sys/bus/w1/devices/28-012043e9b0ed/w1_slave" # Датчик температуры куба
fn1 = "/sys/bus/w1/devices/28-012044272dab/w1_slave" # Датчик температуры колонны
fn2 = "/sys/bus/w1/devices/28-0120442d7835/w1_slave" # Датчик температуры дефлегматора
fn3 = "/sys/bus/w1/devices/28-0120444306f8/w1_slave" # Датчик температуры выходящей воды
#-------------------------------------------------------------------------------
# Переведем консоль в неблокирующий режим с проверкой нажатия клавиши (kbhit)
atexit.register(restore_term)
fd = sys.stdin.fileno()
old_settings = new_settings = termios.tcgetattr(fd)
poller = select.poll()
poller.register(sys.stdin, select.POLLIN)
tty.setcbreak(sys.stdin)
fcntl.fcntl(fd, fcntl.F_SETFL, os.O_NONBLOCK)
#-------------------------------------------------------------------------------
# mode = 0 - чисто "ручной" режим - только мониторинг температур
#        1 - режим "разгона". Мощность ТЭНа = 100%
#        2 - рабочий режим, работа на себя. Мощность ТЭНа = sPDM_600%
#        3 - отбор голов
#        4 - отбор тела
#        5 - отбор хвостов
#        6 - "пропарка" колонны
mode = 0
#-------------------------------------------------------------------------------
timeout = 0 # Максимальное время ожидания в kbhit() в мс. Он же определяет
            # дополнительную задержку в главном цикле программы
#-------------------------------------------------------------------------------
#bus = smbus.SMBus(1) # Шина I2C
#cPDM = 0        # Текущий уровень PDM в контроллере ТЭНа (читается по адресу addrPDM)
#sPDM = 0        # Текущая уставка
#sPDM_600 = 38   # При этом значении PDM и напряжении в сети около 240В мощность
                # ТЭНа будет приблизительно 600 Вт
#-------------------------------------------------------------------------------
T11 = 50.0      # Температура в колонне, выше которой переходим в режим 2 - 
                # просто снижаем мощность нагрева
#-------------------------------------------------------------------------------
# Приводим систему в исходное состояние 
atexit.register(all_off)   # Регистрируем фунцию для "подчистки" всего по концу работы
#try_write_byte(addrPDM, 0) # Выключаем ТЭН
log = open("log", "w")     # Открываем файл журнала
startTime = time.time()    # Фиксируем время начала процесса
rStart = time.time()       # Начало текущего режима работы

# Главный цикл приложения
while True: # Поехали...

  # Обрабатываем состояние клавиатуры
  if kbhit(): # Нажата клавиша
    ch = sys.stdin.read(1)
    if ch == 'q': # Если q, то выходим из цикла. Это конец работы
      break
    elif ord(ch) == 27: # Клавиши, генерирующие Esc-последовательность. 
                        # Ничего не делаем, но очистить остаток в буфере нужно
      sys.stdin.read()
    elif ord(ch) >= 48 and ord(ch) <= 57: # Вводится цифра - это номер режима,
                                          # в который принудительно переводим систему
      oldMode = mode
      mode = int(ch)
      if oldMode <> mode: # При любой смене режима инициализируется переменная 
                          # rStart чтобы знать длительность текущего режима
        rStart = time.time()

  # Измеряем параметры и выводим их в лог и на экран
  T0 = read_temp(fn0) # Измеряем температуру в кубе
  T1 = read_temp(fn1) # Измеряем температуру в колонне
  T2 = read_temp(fn2) # Измеряем температуру в дефлегматоре
  T3 = read_temp(fn3) # Измеряем температуру выходящей воды

#  cPDM = bus.read_byte(addrPDM) # Считываем состояние контроллера ТЭНа (текущую мощность)
  now = time.time() # Текущее время

  # ss - строка для вывода информации на консоль
  ss = "% 7.2f % 7.2f\x1b[33m %d\x1b[0m" % ((now - startTime)/60.0, (now - rStart)/60.0, mode)
  ss += "\x1b[32m% 6.2f\x1b[36m% 6.2f\x1b[32m% 6.2f% 6.2f\x1b[0m" % (T0, T1, T2, T3)
 # ss += "\x1b[31m %3d\x1b[0m" % (cPDM)
  # s - строка для записи информации в журнал (там цветовая раскраска не нужна :)))
  s = time.strftime("%y.%m.%d.%H.%M.%S")
  s += "% 7.2f % 7.2f %d" % ((now - startTime)/60.0, (now - rStart)/60.0, mode)
  s += "% 7.3f% 7.3f% 7.3f% 7.3f" % (T0, T1, T2, T3)
#  s += "% 3d" % (cPDM)

  log.write(s + "\n"); log.flush() # Пишем строку в файл журнала
  print ss # и выводим на экран

  # Теперь выполняем действия, специфические для заданных режимов
#  if mode == 1: # Разгон
 #   sPDM = 100
  #  if T1 >= T11: # Фронт пара проходит по колонне - пора сбрасывать мощность
   #   mode = 2; sPDM = sPDM_600; rStart = now

#  if mode <> 0: # Режим 0 - чисто ручной режим. Не будем вмешиваться...
 #   if cPDM <> sPDM: # Обновим уровень PDM в контроллере ТЭНа, если он не совпадает с уставкой
  #    try_write_byte(addrPDM, sPDM)
